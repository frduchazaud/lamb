module LambSample exposing (MyRecord, TriState, TriState.(..) )

-- Note: If you forget to add a module declaration, Elm will use this one instead:
-- module Main exposing (..)

import Post
-- Post.Post, Post.estimatedReadTime, Post.encode, Post.decoder

import Post as P
-- P.Post, P.estimatedReadTime, P.encode, P.decoder

import Post exposing (Post, estimatedReadTime)
-- Post, estimatedReadTime
-- Post.Post, Post.estimatedReadTime, Post.encode, Post.decoder

import Post as P exposing (Post, estimatedReadTime)
-- Post, estimatedReadTime
-- P.Post, P.estimatedReadTime, P.encode, P.decoder

-- imports are always at the beginning of the file
import Data.List 
import Data.Array as A
import Data.Maybe exposing (Maybe, maybe, withDefault, map, andThen)



-- To begin, here are some type declarations
-- order of declaration does not count

type alias MyInt = Int

-- (Int, String, Char) is a valid type declaration iself
type alias MyTuple = (Int, String, Char)

-- you need a type constructor to create a polymorphic type
type MyTuple a = MyTuple (Int, String, a)

-- some value deeclarations to illustrate type constructor
tuple1 = MyTuple (1, "test", 158) -- : MyTuple Int
tuple2 = MyTuple 100 "test" "ccc" -- : MyTuple String

type alias MyRecord = 
    { x: Int
    , y: Int
    , someOtherField: MyTuple
    }

type TriState = 
    | State1 Int
    | State2
    | State3
    

type MyList a =
    | Nil
    | (::) a (MyList a) -- infix type constructors are valid

infixr 10 ::

-- On doit pouvoir faire du pattern matching sur les champ d'un case
testRecord : TriState -> MyRecord  -> Int
testRecord = \case
    State1 x, _          => x
    State2, { x = 18 }   => 1 -- peu importe le champ y du paramètre MyRecord
    _, { x = 3, y }      => if y >= 30
                                then 2
                                else x |> \x => x * y
    _, r                 => r.x + (.y r)


--| A classic ADT
type Maybe a = Just a
             | Nothing


-- PREMIERE ECRITURE : comme Haskell et Idris, impossible en Elm
withDefault : Maybe a -> a -> a
withDefault Nothing default = default
withDefault (Just x) _ = x

-- DEUXIEME plus contrainte, l'unique possible en Elm
withDefault : Maybe a -> a -> a
withDefault maybe default =
    case maybe of
        Nothing -> default
        (Just x) -> x

-- TROISIEME, à envisager :
withDefault : Maybe a -> a -> a
withDefault = \case -- il s'agit d'une lambda qui envoie tous ses paramètres dans un case
    Nothing, default -> default -- on note les virgule pour séparer les cas
    (Just x), _ -> x



--| For later: a GADT
type Expr a : Num a => Type
    ExprInt Int       : Int -> Expr
    ExprAdd Expr Expr : Expr -> Expr -> Expr
    ExprScale Int Expr: Int -> Expr -> Expr
    deriving (Eq, Ord, Enum, Bounded, Show, Read) -- default instance provided for these interfaces


--| A typeclass
interface Show a where
    show : a -> String
    -- with default implementation
    show x = "Not yet implemented"

--| Instances declarations are terse in Idris (no keyword)
--| But Haskell ones are easiers to read (and to parse!)
instance Show MyRecord
    show { x, y, someOtherField, _ } = "{ x=" ++ show x ++ ", y" ++ show y  ++ ", somesomeOtherField=" ++ show someOtherField ++ " }"

-- l'exemple de ces instances est inutile, car on voudrait pouvoir dériver automatiquement certaines interfaces comme 'Show', avec 'deriving'
instance Show MyTuple
    show (i, s, c) = "(" ++ show i ++ ", " ++ show s ++ ", " show c ++ ")"

--| Some functions
fact : Nat -> Integer
fact n =
    let
        fact' : Integer -> Integer
        fact 0 = 0
        fact 1 = 1
        fact n = n *        
    in 
        fact' (n |> toInteger)

--| String usage
-- String is made of Char (UTF8).
-- La gestion des différentes tailles de Char implique l'intervention du compilateur
-- Byte est un entier sur 7 bits (Byte7) ou 8 bits (Byte8)
-- Regarder comment fonctionne Haskell avec Text sur le sujet.


--| Unit Type. In Haskell the name of this type is '()'.
-- In Lamb we make a disctinction btw the type and the real value (unique).
type Unit = ()

--| expérimentation des listes strictes et des séquences paresseuses en tenant compte
-- Collection est plutôt une interface (à voir)
interface Coll a = [a] -- '=' notation here reserved to primitive or a new kind of alias ?
interface alias Coll a = [a] --  alternative clearer

interface Seq a -- Coll with Lazy evaluation

interface Inf a where -- struct which CAN be infinite. Used to help enforce totality of computations
    take : Nat -> Inf a -> Fin a
    drop : Nat -> Inf a -> Inf a
    slice: Nat -> Nat -> Inf a 

interface Fin a -- 'a' is a struct which is garanteed to be finite


-- les opérations disponibles sur Inf sont aussi disponibles sur Fin
instance Inf (Fin a)

--| Some instances
instance Coll (List a) -- classic linked list
instance Coll (Array a) -- boxed in the heap
instance Coll (Vect a) -- unboxed. Collection type by defaut because the most efficient in most common cases
instance Coll (Seq a) -- Seq peut servir à gérer des flux, des channels, des IO (sockets)

type alias FinSeq a = Fin (Seq a) 
type alias InfSeq a = Inf (Seq a) 

-- | List litterals polymorphism
-- la notation [] est polymorphique par défaut. Elle peut donc produire directement n'importe quel type de collection.

-- without type annotation, it's a Vect Int
-- oneVect : Vect Int
oneVect = [1, 2, 3]

-- Otherwise type constraint is necessary e.g. by explicit type annotation
oneList : List Char
oneList = ['a', 'b']

-- type constraint provided by the caller signature
testCollFn : Seq a -> Nat
testCollFn xs =
    head? xs

-- ici on impose le type 'Seq a' à 'oneVect'. Son type par défaut ne s'applique plus
-- et on obtient donc en réalité => oneVect : Seq Int
testColl = testCollFn oneVect

-- Convention : quand une fonction renvoie un 'Maybe a', son nom doit se terminer par '?'
-- à ne pas confondre avec la notation ?typedHole
head? : Seq a -> Maybe a
head = \case
    []           -> Nothing -- coll literal : ici lu comme un 'Seq'
    x :: _ -> Just x  -- le constructeur :: appartient soit à List soit à Seq. Le compilateur utilise le bon en fonction du contexte, donc 'Seq'

-- le fonctionnement des Maybe



    
    




-- | List comprehensions (LC)
-- une LC a pour type [a] // ie Collection a
-- si le type de la valeur générée n'est pas spécifié
-- (par annotation de type ou par inférrence de type)
-- alors la notation est un
lc1 = []


-- | Evaluation strategy
-- strictly evaluated
-- special type Lazy, comme dans Idris : le compilateur fait le boulot :
--  * pas la peine d'envoyer un type Lazy dans la fonction (avec 'defer')
--  * pas la peine de lancer explicitement le calcul du thunk dans la fonction (avec 'force')
--
-- L'évaluation stricte reste prioritaire quand le compilateur ne peut déterminer s'il doit calculer les thunks.

-- Exemple Lazy simple
ifFn : Bool -> Lazy a -> Lazy a -> a
ifFn True thn _ = thn
ifFn False _ els = els


-- Exemple complet
-- BEGIN EXAMPLE
calculSuperLong : Int -> Int
calculSuperLong x = ...

testLazy : Lazy Int -> Lazy Char -> Lazy String -> Bool -- on peut imaginer qu'en interne le compilateur peut inliner 2^3 versions de la fonction pour gérer les Lazy.
testLazy li lc ls =                                     -- certaines de ces versions seront inutiles et élaguées, ou alors il encapsule au besoin les paramètres Lazy dans des thunk
    if lc = 'a' then -- déclenche le calcul de 'lc' si c'est un thunk
        True
    else if ls = "stop" then -- déclenche le calcul de 'ls' (si c'est un thunk)
        True
    else
        li == 0 -- déclenche le calcul de manière conditionnelle, si la valeur est ensuite utilisée sur un site d'appel non Lazy.
                -- permet d'économiser des calculs potentiellement longs, à condition que ce gain soit déterminé de manière certaine par le compilateur dans le contexte
                -- Donc : choix déterminé statiquement par le compilateur. Si doute, alors calcul lancé.
                -- Dans l'absolu, le compilateur pourrait générer deux versions de cette fonction : une qui renvoie un "Bool" et une qui renvoie un "Lazy Bool"
                -- Si le programmeur veut absolument du Lazy en retour, il lui suffit de l'indiquer dans le type de retour de la fonction

testLazyConsummer : Bool -> Result Bool String
testLazyConsummer launchCalculus =
    let 
        testLazyVal =
            testLazy (calculSuperLong 2) 'c' "ok" -- on ne sait pas encore s'il faut le calculer. Le calcul sera déclenché si besoin
    in
    if launchCalculus then
        Ok <| testLazyVal -- le résultat de testLazy est consommé à coup sûr. On lance le calcul.
    else
        Err "pb!" -- le réstultat de testLazy n'est pas consommé. Inutile de le calculer

--

testLazyReturnsLazy : Lazy Int -> Lazy Bool
testLazyReturnsLazy li =
    li == 0 -- ne lance pas le calcul mais retourne un thunk

testLazyConsummer2 : Bool
testLazyConsummer2 =
    testLazyReturnsLazy 1 -- lance le calcul du thunk retourné.

-- END EXAMPLE


--| Fonctionnalité d'agent ou d'acteur (Erlang / Gleam...)
-- Voir notamment : https://hackage.haskell.org/package/hactors-0.0.3.1/docs/Control-Concurrent-Actor.html
-- Utile pour concevoir les types qui vont derrière
-- Cependant, dans un souci de simplicité, il serait mieux de l'intégrer au langage comme le fait Erlang

-- voici une syntaxe inspirée d'Erlang. Le 'receive' fonctionne comme un 'case' ou un 'select' en go
actor: Actor Pid -> Pid
actor pid autrePid
receive
     Message1 -> send autrePid "voici un message"
     Message2 -> expr2
after
     Timeout ->
        ActionTimeOut

register pid -- what?
spawn (actor pid)

-- Tentative de typage...
type alias ActorRef msg = 
  { refId   :: ThreadId
  , refMbox :: TQueue msg
  } deriving (Eq)

type alias Behaviour msg = { getBehaviour :: msg -> IO (Behaviour msg) }

spawn : Behaviour msg -> IO (ActorRef msg)
send : ActorRef msg -> msg -> IO ()



--| Voici les types de Control.Concurrent.Actor (Haskell)
type alias Process = ThreadId

self : IO Process
kill : IO Process -> IO ()
exit : IO ()
sleep : Int -> IO ()
wait : IO ()
say : String -> IO ()

type MBox m = TChan m
type alias Actor m =
    { proc :: Process
    , mbox :: MBox m
    }

actor : t -> (t -> MBox m -> IO a) -> IO (Actor m)
spawn : (MBox m -> IO a) -> IO (Actor m)
receive :: MBox m -> (m -> IO a) -> IO b
(?) : MBox m -> (m -> IO a) -> IO b
(<?) : IO (MBox m) -> (m -> IO a) -> IO b
send : Actor m -> m -> IO m
(!) : Actor m -> m -> IO m
(<!) : IO (Actor m) -> m -> IO m
(!>) : Actor m -> IO m -> IO m
(<!>) : IO (Actor m) -> IO m -> IO m
spawn_receive: (m -> IO a) -> IO (Actor m)
on_exception : IO a -> IO a -> IO a
tolerant : IO a -> IO a
faultable : IO () -> IO ()

-- FIN des types de Control.Concurrent.Actor (Haskell)


--| Unités : inspiration du F#
-- Mass, grams.
measure type g
-- Mass, kilograms.
measure type kg
-- Weight, pounds.
measure type lb

-- Distance, meters.
measure type m
-- Distance, cm
measure type cm

-- Distance, inches.
measure type inch
-- Distance, feet
measure type ft

-- Time, seconds.
measure type s

-- Force, Newtons.
measure type N = kg m / s^2

-- Pressure, bar.
measure type bar
-- Pressure, Pascals
measure type Pa = N / m^2

-- Volume, milliliters.
measure type ml
-- Volume, liters.
measure type L

-- Define conversion constants.
gramsPerKilogram : float<g kg^-1> = 1000.0<g/kg>
cmPerMeter : float<cm/m> = 100.0<cm/m>
cmPerInch : float<cm/inch> = 2.54<cm/inch>

mlPerCubicCentimeter : float<ml/cm^3> = 1.0<ml/cm^3>
mlPerLiter : float<ml/L> = 1000.0<ml/L>

-- Define conversion functions.
convertGramsToKilograms (x : float<g>) = x / gramsPerKilogram
convertCentimetersToInches (x : float<cm>) = x / cmPerInch



--| valeurs réactives

x : React Int
x = R 10

x2 : React Int
x2 = [| !x * !x |] -- ou une notation comme ça, voir Idris

-- Doit fonctionner avec les Effets comme Idris : Gestion du STATE
-- la gestion du graphe sous-jacent est fournie par le compilateur
-- il faudrait aussi avoir une capacité d'introspection en donnant accès au graphe mais pas facile
-- on doit aussi pouvoir modifier les "formules" depuis l'IO sous forme de String puis les "compiler",
-- pas facile...



--| Gestion des threads
-- un thread est un Worker qui se voit attribuer des Tasks
-- Il existe 3 threads par défaut : UiWorker, GpuWorker, IoWorker


-- fin